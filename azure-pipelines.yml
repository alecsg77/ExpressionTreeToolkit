name: $(GITVERSION_FullSemVer)

trigger:
  - "master"
  - "hotfix/*"
  - "release/*"
  - "develop"
  - "feature/*"

pr:
  - "master"
  - "develop"

pool:
  vmImage: windows-latest

variables:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: "true"
  DOTNET_CLI_TELEMETRY_OPTOUT: "true"
  ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/master') }}:
    branch: master
  ${{ if startsWith(variables['Build.SourceBranch'], 'refs/heads/hotfix/') }}:
    branch: hotfix
  ${{ if startsWith(variables['Build.SourceBranch'], 'refs/heads/release/') }}:
    branch: release
  ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/develop') }}:
    branch: develop
  ${{ if startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/') }}:
    branch: feature
  ${{ if startsWith(variables['Build.SourceBranch'], 'refs/pull/') }}:
    branch: pull-request

stages:
  - stage: ci
    displayName: Continuous integration
    variables:
      BuildConfiguration: "Release"
      NuGet.Packages: $(Pipeline.Workspace)/.nuget/packages

    jobs:
      - job: build
        displayName: Build
        steps:
          - checkout: self
            displayName: "Checkout $(Build.SourceBranch)"
            submodules: true

          - task: UseDotNet@2
            displayName: "Install .Net SDK"
            inputs:
              useGlobalJson: true
              performMultiLevelLookup: true

          - task: UseDotNet@2
            displayName: "Install .Net Core 2.1.x Runtime"
            inputs:
              version: 2.1.x
              packageType: runtime
              performMultiLevelLookup: true

          - task: UseDotNet@2
            displayName: "Install .Net Core 3.1.x Runtime"
            inputs:
              version: 3.1.x
              packageType: runtime
              performMultiLevelLookup: true

          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | **/packages.lock.json,!**/bin/**'
              restoreKeys: |
                nuget | "$(Agent.OS)"
              path: $(NuGet.Packages)

          - task: DotNetCoreCLI@2
            displayName: "dotnet restore"
            inputs:
              command: restore
              projects: |
                src/**/*.csproj 
                test/**/*.csproj
                docfx/**/*.proj
              feedsToUse: config
              nugetConfigPath: nuget.config

          - task: DotNetCoreCLI@2
            name: source
            displayName: "dotnet build"
            inputs:
              command: build
              projects: "src/**/*.csproj"
              arguments: "--configuration $(BuildConfiguration) --no-restore"

          - task: DotNetCoreCLI@2
            displayName: "dotnet test"
            inputs:
              command: test
              projects: "test/**/*.UnitTests/*.csproj"
              arguments: "--configuration $(BuildConfiguration) --no-restore"

          - task: DotNetCoreCLI@2
            displayName: "dotnet pack release"
            inputs:
              command: pack
              packagesToPack: "src/**/*.csproj"
              configurationToPack: "$(BuildConfiguration)"
              packDirectory: "$(Build.ArtifactStagingDirectory)/packages"
              nobuild: true

          - publish: "$(Build.ArtifactStagingDirectory)/packages"
            displayName: "Publish Artifact: packages"
            artifact: packages

          - task: DotNetCoreCLI@2
            displayName: "docfx build"
            env:
              DOCFX_SOURCE_BRANCH_NAME: "$(Build.SourceBranchName)"
            inputs:
              command: build
              projects: "docfx/**/*.proj"
              arguments: "--configuration $(BuildConfiguration)"

          - task: CopyFiles@2
            displayName: "Copy To Artifact: docfx"
            inputs:
              SourceFolder: $(Build.SourcesDirectory)/docfx/_site
              TargetFolder: $(Build.ArtifactStagingDirectory)/docfx
              CleanTargetFolder: true

          - publish: "$(Build.ArtifactStagingDirectory)/docfx"
            displayName: "Publish Artifact: docfx"
            artifact: docfx

  - stage: publish
    displayName: Publish
    dependsOn: ci
    condition: and(succeeded(), in(variables.branch, 'develop', 'release', 'hotfix', 'master'))
    jobs:
      - deployment: ci
        displayName: CI
        environment: myget
        strategy:
          runOnce:
            preDeploy:
              steps:
                - checkout: none
                - download: current
                  artifact: packages
            deploy:
              steps:
                - task: NuGetCommand@2
                  name: push
                  displayName: "MyGet push"
                  inputs:
                    command: push
                    packagesToPush: "$(Pipeline.Workspace)/packages/**/*.nupkg"
                    nuGetFeedType: external
                    publishFeedCredentials: "MyGet - ExpressionTreeToolkit"

      - deployment: nuget
        displayName: NuGet
        environment: nuget
        condition: and(succeeded(), in(variables.branch, 'release', 'hotfix', 'master'))
        strategy:
          runOnce:
            preDeploy:
              steps:
                - checkout: none
                - download: current
                  artifact: packages

            deploy:
              steps:
                - task: NuGetCommand@2
                  name: nuget
                  displayName: "NuGet push"
                  inputs:
                    command: push
                    packagesToPush: "$(Pipeline.Workspace)/packages/**/*.nupkg"
                    nuGetFeedType: external
                    publishFeedCredentials: "NuGet - ExpressionTreeToolkit"

      - deployment: ghpages
        displayName: GitHub Pages
        environment: gh-pages
        condition: and(succeeded(), in(variables.branch, 'master'))
        variables:
          GitHub.UserName: "Alessio Gogna"
          GitHub.UserEmail: "alecsg77@users.noreply.github.com"
          Version.Tag: $[ format('v{0}', stageDependencies.ci.build.outputs['source.GitVersion.SemVer']) ]
        strategy:
          runOnce:
            preDeploy:
              steps:
                - checkout: self
                  clean: true
                  persistCredentials: true
                  path: gh-pages
                - download: current
                  artifact: docfx
            deploy:
              steps:
                - script: |
                    git checkout --progress --no-recurse-submodules -f gh-pages
                    git rm -rf .
                  displayName: "Checkout gh-pages & Clean"
                  workingDirectory: $(Pipeline.Workspace)/gh-pages
                - task: CopyFiles@2
                  displayName: "Copy Files from docfx to $(Pipeline.Workspace)/gh-pages"
                  inputs:
                    SourceFolder: "$(Pipeline.Workspace)/docfx"
                    TargetFolder: "$(Pipeline.Workspace)/gh-pages"
                - script: |
                    git add -v .
                    git -c user.name="$(GitHub.UserName)" -c user.email="$(GitHub.UserEmail)" commit -a -v -m "$(Version.Tag)"
                    git tag $(Version.Tag)
                    git push -v --tags origin gh-pages
                  displayName: "Add & Commit & Push gh-pages"
                  workingDirectory: $(Pipeline.Workspace)/gh-pages

  - stage: release
    displayName: Release
    dependsOn:
      - ci
      - publish
    jobs:
      - job: github
        displayName: GitHub
        variables:
          Version.Tag: $[ format('v{0}', stageDependencies.ci.build.outputs['source.GitVersion.SemVer']) ]
        steps:
          - checkout: none
          - download: none
          - task: GitHubRelease@1
            displayName: Create GitHub Release
            name: githubrelease
            inputs:
              action: edit
              gitHubConnection: "GitHub connection"
              tagSource: userSpecifiedTag
              tag: $(Version.Tag)
              isPreRelease: ${{ ne(variables.branch, 'master') }}
              isDraft: ${{ notIn(variables.branch, 'release', 'hotfix', 'master') }}
              assetUploadMode: delete
              assets: |
                $(Pipeline.Workspace)/packages/**/*.nupkg
                $(Pipeline.Workspace)/packages/**/*.snupkg
